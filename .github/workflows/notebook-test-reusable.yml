name: Reusable Notebook Testing Workflow

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment to test against (prod or dev)'
        required: false
        default: 'prod'
        type: string
      notebook_selection:
        description: 'How to select notebooks (all or changed)'
        required: false
        default: 'all'
        type: string
      notebooks_json:
        description: 'JSON array of notebooks to test (used when notebook_selection=changed)'
        required: false
        default: '[]'
        type: string
      base_sha:
        description: 'Base SHA for change detection (used when notebook_selection=changed)'
        required: false
        type: string
      head_sha:
        description: 'Head SHA for change detection (used when notebook_selection=changed)'
        required: false
        type: string

jobs:
  detect-notebooks:
    runs-on: ubuntu-latest
    outputs:
      notebooks: ${{ steps.set-notebooks.outputs.notebooks }}
      has-notebooks: ${{ steps.set-notebooks.outputs.has-notebooks }}
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: ${{ inputs.notebook_selection == 'changed' && 0 || 1 }}

    - name: Set notebooks to test
      id: set-notebooks
      run: |
        # Check if config file exists
        if [ ! -f ".github/notebooks-config.json" ]; then
          echo "ERROR: Configuration file .github/notebooks-config.json not found"
          ls -la .github/
          exit 1
        fi
        
        # Validate JSON syntax
        if ! jq empty .github/notebooks-config.json; then
          echo "ERROR: Invalid JSON in configuration file"
          cat .github/notebooks-config.json
          exit 1
        fi
        
        if [ "${{ inputs.notebook_selection }}" = "all" ]; then
          # Get all notebooks from config
          notebooks=$(jq -c '.python_notebooks' .github/notebooks-config.json)
          has_notebooks=true
          echo "üìã Testing all notebooks"
        else
          # Use provided notebooks JSON or detect changes
          if [ "${{ inputs.notebooks_json }}" != "[]" ]; then
            notebooks='${{ inputs.notebooks_json }}'
            has_notebooks=true
            echo "üìã Testing provided notebooks"
          else
            # Detect changed notebooks
            notebooks="[]"
            has_notebooks=false

            # Validate that we have the required SHAs for change detection
            if [ -z "${{ inputs.base_sha }}" ] || [ -z "${{ inputs.head_sha }}" ]; then
              echo "ERROR: base_sha and head_sha are required for change detection"
              exit 1
            fi

            # Get list of changed files
            echo "Comparing ${{ inputs.base_sha }} to ${{ inputs.head_sha }}"
            changed_files=$(git diff --name-only ${{ inputs.base_sha }} ${{ inputs.head_sha }})
            
            # Check each notebook to see if it changed
            while IFS= read -r notebook_info; do
              name=$(echo "$notebook_info" | cut -d'|' -f1)
              path=$(echo "$notebook_info" | cut -d'|' -f2)
              
              if echo "$changed_files" | grep -q "$path"; then
                notebooks=$(echo "$notebooks" | jq --arg name "$name" --arg path "$path" '. += [{"name": $name, "path": $path}]')
                has_notebooks=true
                echo "‚úì Notebook $name needs testing"
              fi
            done < <(jq -r '.python_notebooks[] | "\(.name)|\(.path)"' .github/notebooks-config.json)
          fi
        fi

        # Output results
        echo "notebooks=$(echo "$notebooks" | jq -c .)" >> $GITHUB_OUTPUT
        echo "has-notebooks=$has_notebooks" >> $GITHUB_OUTPUT
        
        # Debug output
        notebook_count=$(echo "$notebooks" | jq length)
        echo "üìä Total notebooks to test: $notebook_count"

  setup-python:
    runs-on: ubuntu-latest
    needs: detect-notebooks
    if: needs.detect-notebooks.outputs.has-notebooks == 'true'
    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Cache Python dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install jupyter

  execute-notebooks:
    runs-on: ubuntu-latest
    needs: [detect-notebooks, setup-python]
    if: needs.detect-notebooks.outputs.has-notebooks == 'true'
    continue-on-error: true
    env:
      ENV: ${{ inputs.environment }}
    strategy:
      fail-fast: false
      matrix:
        notebook: ${{ fromJson(needs.detect-notebooks.outputs.notebooks) }}
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Set up environment variables
      run: |
        echo "ENV variable is set to: $ENV"
        if [ "$ENV" = "dev" ]; then
          echo "üîß Running in DEV environment"
        else
          echo "üöÄ Running in PROD environment"
        fi

    - name: Restore Python dependencies cache
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install jupyter

    - name: Execute notebook
      run: |
        env_prefix=""
        if [ "$ENV" = "dev" ]; then
          env_prefix="(dev) "
        fi
        
        echo "${env_prefix}Executing notebook: ${{ matrix.notebook.path }}"
        set +e  # Don't exit on error immediately
        jupyter nbconvert --execute --to notebook --inplace "${{ matrix.notebook.path }}"
        EXIT_CODE=$?
        set -e  # Re-enable exit on error
        
        if [ $EXIT_CODE -ne 0 ]; then
          echo "‚ùå Notebook execution failed with exit code $EXIT_CODE"
          if [ "$ENV" = "dev" ]; then
            echo "This likely indicates the DEV API is not accessible or the notebook encountered an error"
          fi
          echo "FAILED" > results-${{ matrix.notebook.name }}.txt
          exit 1  # Fail this step
        else
          echo "‚úÖ Notebook executed successfully"
          echo "SUCCESS" > results-${{ matrix.notebook.name }}.txt
        fi

    - name: Upload results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: notebook-results-${{ matrix.notebook.name }}
        path: results-${{ matrix.notebook.name }}.txt

    - name: Upload notebook
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.notebook.name }}
        path: ${{ matrix.notebook.path }}

  check-results:
    runs-on: ubuntu-latest
    needs: [detect-notebooks, execute-notebooks]
    if: always() && needs.detect-notebooks.outputs.has-notebooks == 'true'
    steps:
    - name: Gather all notebook results
      uses: actions/download-artifact@v4
      with:
        path: results/

    - name: Check notebook results
      run: |
        env_prefix=""
        if [ "${{ inputs.environment }}" = "dev" ]; then
          env_prefix="(dev) "
        fi
        
        echo "${env_prefix}Checking notebook execution results..."
        
        find results/ -name "results-*.txt" -exec cat {} \;
        
        FAILED_COUNT=$(find results/ -name "results-*.txt" -exec grep -l "FAILED" {} \; | wc -l)
        TOTAL_COUNT=$(find results/ -name "results-*.txt" | wc -l)
        
        echo "Total notebooks: $TOTAL_COUNT"
        echo "Failed notebooks: $FAILED_COUNT"
        
        if [ "$FAILED_COUNT" -gt 0 ]; then
          echo "‚ùå $FAILED_COUNT out of $TOTAL_COUNT notebooks failed execution."
          find results/ -name "results-*.txt" -exec grep -l "FAILED" {} \; | while read file; do
            notebook_name=$(basename "$file" | sed 's/results-\(.*\)\.txt/\1/')
            echo "Failed notebook: $notebook_name"
          done
          exit 1
        else
          echo "‚úÖ All $TOTAL_COUNT notebooks executed successfully!"
        fi

  no-notebooks:
    runs-on: ubuntu-latest
    needs: detect-notebooks
    if: needs.detect-notebooks.outputs.has-notebooks == 'false'
    steps:
    - name: No notebooks to test
      run: |
        if [ "${{ inputs.notebook_selection }}" = "changed" ]; then
          echo "‚úÖ No Python notebooks were changed. Skipping execution."
        else
          echo "‚ö†Ô∏è No notebooks found to test."
        fi