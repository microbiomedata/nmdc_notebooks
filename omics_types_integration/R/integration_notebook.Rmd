---
title: "Untitled"
output: html_document
date: "2024-11-26"
---

This notebook is an example of how different omics data types may be linked via commonly used annotation vocabularies and investigated together. In this notebook we explore biomolecules and KEGG pathways identified in a set of samples that have processed metagenomic, metaproteomics, and metabolomics data available in the NMDC Data Portal.

NOTE: This notebook uses the KEGGREST R package to interface with the KEGG API. Use of the KEGG API and KEGGREST is restricted to academic users. Non-academic users must obtain a commercial license. (See https://www.kegg.jp/kegg/legal.html) The National Microbiome Data Collaborative use of KEGG is covered by license (license information).

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr, warn.conflicts = FALSE)
library(tidyr, warn.conflicts = FALSE)
library(stringr, warn.conflicts = FALSE)
library(readr, warn.conflicts = FALSE)
library(purrr)
library(ggplot2, warn.conflicts = FALSE)
library(jsonlite)
library(KEGGREST)
library(httr)
library(circlize)
```

## Retrieve data from the NMDC database using API endpoints

### Choose data to retrieve

The NMDC data portal (https://data.microbiomedata.org/) allow us to filter data and samples according to many criteria. In this case, we use the Data Type filters (upset plot) to identify samples that have metagenomics, metaproteomics, and metabolomics data. This returns 33 samples from the study "Riverbed sediment microbial communities from the Columbia River, Washington, USA" (https://data.microbiomedata.org/details/study/nmdc:sty-11-aygzgv51).

### Retrieve and filter data for Columbia River sediment study

The study page linked above has the NMDC study identifier in the URL: `nmdc:sty-11-aygzgv51`. We will use the function `get_data_objects_for_study` (defined in `utility_functions.R`) to retrieve all records that represent data. This includes raw data files (e.g. FASTQ or mass spectra files) as well as processed data results output by the NMDC workflows.

```{r pull-data-object-records}

# Retrieve all data objects associated with this study
dobj <- jsonlite::fromJSON('https://api.microbiomedata.org/data_objects/study/nmdc%3Asty-11-aygzgv51') %>% 
  unnest()
```

In this case, we want to look at the processed data results for our three omics types of interest. Specifically, we want the files containing KEGG Orthology and Enzyme Commission annotations. 

One way of further identifying a NMDC `DataObject` record is by looking at its slot `data_object_type` (https://microbiomedata.github.io/nmdc-schema/data_object_type/), which contains a value from `FileTypeEnum` (https://microbiomedata.github.io/nmdc-schema/FileTypeEnum/). Based on the descriptions of `FileTypeEnum` permissible values we want to filter for results files with the following `data_object_type` values:

| Value | Description |
|:-----:|:-----------:|
|Annotation Enzyme Commission|Tab delimited file for EC annotation|
|Annotation KEGG Orthology|Tab delimited file for KO annotation|
|GC-MS Metabolomics Results|GC-MS-based metabolite assignment results table|
|Protein Report|Filtered protein report file|

```{r filter-data-objects}

dobj <- dobj %>%
  # Filter to biosamples with metagenome EC annotations, metagenome KO 
  # annotations, metaproteomics results, and metabolomics results
  group_by(biosample_id) %>%
  filter("Annotation Enzyme Commission" %in% data_object_type &
           "Annotation KEGG Orthology" %in% data_object_type & 
           "GC-MS Metabolomics Results" %in% data_object_type &
           "Protein Report" %in% data_object_type) %>%
  ungroup() %>%
  
  # Remove uninformative columns for simpler dataframe
  select(-c(alternative_identifiers, in_manifest, was_generated_by))

```
head()
### Download selected results files
 
Now we can use the `url` slot from the filtered `DataObject` records to read in all of the files containing the annotations of interest.

```{r download-results}

results_by_biosample <- dobj %>%
  
  # Filter to desired results file types and create one URL column per type
  filter(data_object_type %in% c("Annotation Enzyme Commission", "Annotation KEGG Orthology",
                                 "GC-MS Metabolomics Results", "Protein Report")) %>%
  select(biosample_id, data_object_type, url) %>%
  pivot_wider(names_from = data_object_type, values_from = url) %>%
  
  # Read in the TSV/CSV results files
  # Add in column names from the IMG genome download README
  mutate(metag_ec_results = lapply(
    .$`Annotation Enzyme Commission`, 
    function(x) { 
      d <- read_tsv(x, col_names = FALSE, show_col_types = FALSE)
      names(d) <- c("gene_id", "img_ko_flag", "EC", "percent_identity",
                    "query_start", "query_end", "subj_start", "subj_end",
                    "evalue", "bit_score", "align_length")
      d
      })) %>%
  
  mutate(metag_ko_results = lapply(
    .$`Annotation KEGG Orthology`, 
    function(x) { 
      d <- read_tsv(x, col_names = FALSE, show_col_types = FALSE)
      names(d) <- c("gene_id", "img_ko_flag", "ko_term", "percent_identity",
                    "query_start", "query_end", "subj_start", "subj_end",
                    "evalue", "bit_score", "align_length")
      d
      })) %>%

  mutate(metap_results = lapply(.$`Protein Report`, read_tsv, col_names = TRUE, show_col_types = FALSE)) %>%
  mutate(metab_results = lapply(.$`GC-MS Metabolomics Results`, read_csv, col_names = TRUE, show_col_types = FALSE))


```

Each of the downloaded data files contains lots of information including the KO, EC, or KEGG Compound identifiers.

```{r}

head(results_by_biosample$metag_ko_results[[1]])

```

From each results table we can extract the unique list of genes/proteins/metabolites identified in that sample.

```{r unique-identifications}

# Metagenome annotations - Enzyme Commission
metag_ec_unique_df <- results_by_biosample %>%
  distinct(biosample_id, .keep_all = TRUE) %>%

  # Save a unique vector of annotations by type for each sample for searching later
  mutate(metag_ec_unique = lapply(.$metag_ec_results, 
                                  FUN = function(x) { sort(unique(x$EC)) })) %>%
  select(biosample_id, metag_ec_results, metag_ec_unique)



# Metagenome annotations - KEGG Orthology
metag_ko_unique_df <- results_by_biosample %>%
  distinct(biosample_id, .keep_all = TRUE) %>%

  # Save a unique vector of annotations by type for each sample for searching later
  mutate(metag_ko_unique = lapply(.$metag_ko_results, 
                                  FUN = function(x) { sort(unique(x$ko_term)) })) %>%
  select(biosample_id, metag_ko_results, metag_ko_unique)



# Metaproteome annotations - Enzyme Commission
metap_ec_unique_df <- results_by_biosample %>%
  distinct(biosample_id, .keep_all = TRUE) %>%

  # Save a unique vector of annotations by type for each sample for searching later
  mutate(metap_ec_unique = lapply(
    .$metap_results, 
    FUN = function(x) { sort(unique(x$EC_Number)) %>% strsplit(",") %>% unlist() })) %>%
  select(biosample_id, metap_results, metap_ec_unique)



# Metabolome annotations - KEGG Compound
metab_ko_unique_df <- results_by_biosample %>%
  distinct(biosample_id, .keep_all = TRUE) %>%

  # Save a unique vector of annotations by type for each sample for searching later
  mutate(metab_ko_unique = lapply(.$metab_results, 
                                  FUN = function(x) { sort(unique(x$`Kegg Compound ID`)) })) %>%
  select(biosample_id, metab_results, metab_ko_unique)


# rm(results_by_biosample)

```

## Get IDs from other KEGG databases

Now we will use the KEGGREST package (available on Bioconductor) to make calls to the KEGG API. Using the annotations provided in the workflow results, we can look up the corresponding annotations in other KEGG databases to start drawing connections between biomolecule identifications.

### Gather metabolite information

First we will find all of the Enzyme Commission numbers available for each identified compound. These EC numbers represent enzymes involved in recorded reactions that produce the compound of interest.

```{r get-other-metabolite-info}

# For each sample, assemble a dataframe of metabolite information

# Pre-allocate an empty list for metabolite dataframes
metabolite_annotations_list <- vector(mode = "list", length = length(metab_ko_unique_df$biosample_id))

for (biosample in 1:length(metab_ko_unique_df$biosample_id)) {

  unique_metabolites <- metab_ko_unique_df$metab_ko_unique[[biosample]]

  # Get EC ids for each metabolite
  ec_from_metabolites <- keggLink("enzyme", unique_metabolites)

  ec_from_metabolites <- data.frame(compound_id = names(ec_from_metabolites),
                                    ec_id = ec_from_metabolites) %>%
    nest(.by = compound_id, .key = "ec_id")

  # Get modules for each metabolite
  modules_from_metabolites <- keggLink("module", unique_metabolites)

  modules_from_metabolites <- data.frame(compound_id = names(modules_from_metabolites),
                                        module_id = modules_from_metabolites) %>%
    nest(.by = compound_id, .key = "module_id")


  # Get pathways for each metabolite
  pathways_from_metabolites <- keggLink("pathway", unique_metabolites)

  pathways_from_metabolites <- data.frame(compound_id = names(pathways_from_metabolites),
                                          pathway_id = pathways_from_metabolites) %>%
    nest(.by = compound_id, .key = "pathway_id")

  # Join compound, EC, module, pathway IDs into one dataframe
  metabolite_annotations <- data.frame(compound_id = paste0("cpd:", unique_metabolites)) %>%
    left_join(ec_from_metabolites) %>%
    left_join(modules_from_metabolites) %>%
    left_join(pathways_from_metabolites) %>%
    mutate(compound_trimmed = unique_metabolites) %>%
    
    # Search for the EC IDs in the unique identification lists 
    # for the other biomolecules in this sample
    mutate(In_Metag_Annotations = vapply(.$ec_id, function(x) { any(x$ec_id %in% tolower(metag_ec_unique_df$metag_ec_unique[[biosample]])) },
                            FUN.VALUE = TRUE)) %>%
    mutate(In_Prot_Annotations = vapply(.$ec_id, function(x) { any(x$ec_id %in% tolower(metap_ec_unique_df$metap_ec_unique[[biosample]])) },
                            FUN.VALUE = TRUE))

  # Save dataframe to list
  metabolite_annotations_list[[biosample]] <- metabolite_annotations
}
```






```{r}

# For each sample, assemble a dataframe of protein information

# Pre-allocate an empty list for protein dataframes
protein_annotations_list <- vector(mode = "list", length = length(metap_ec_unique_df$biosample_id))

for (biosample in 1:length(metap_ec_unique_df$biosample_id)) {

  # Gather protein annotations from workflow output
  protein_annotations <- metap_ec_unique_df$metap_results[[biosample]] %>%
    select(KO, EC_Number) %>%
    rename(ko_id = KO, ec_id = EC_Number) %>%
    mutate(ec_id = trimws(strsplit(ec_id, ","))) %>%
    filter(if_any(everything(), ~ !is.na(.))) %>%
    distinct() %>%
    mutate(ko_trimmed = substring(ko_id, 4))
  
  unique_proteins <- protein_annotations$ko_trimmed
  
  # Get modules for each protein
  modules_from_proteins <- keggLink("module", unique_proteins)
  
  modules_from_proteins <- data.frame(ko_id = toupper(names(modules_from_proteins)),
                                      module_id = modules_from_proteins) %>%
    nest(.by = ko_id, .key = "module_id")
  
  
  # Get pathways for each protein
  pathways_from_proteins <- keggLink("pathway", unique_proteins)
  
  pathways_from_proteins <- data.frame(ko_id = toupper(names(pathways_from_proteins)),
                                       pathway_id = pathways_from_proteins) %>%
    nest(.by = ko_id, .key = "pathway_id")

  
  # Join KO, EC, module, pathway IDs into one dataframe
  protein_annotations <- protein_annotations %>%
    left_join(modules_from_proteins) %>%
    left_join(pathways_from_proteins) %>%
    
    # Search for corresponding biomolecules in other data types for this sample
    mutate(In_Metab_Annotations = vapply(.$ec_id, function(x) { any(tolower(x) %in% unique(unlist(metabolite_annotations_list[[biosample]]$ec_id))) },
                                         FUN.VALUE = TRUE)) %>%
    mutate(In_Metag_Annotations = vapply(.$ko_id, function(x) { any(x %in% unique(metag_ko_unique_df$metag_ko_unique[[biosample]])) },
                                         FUN.VALUE = TRUE))
  
  # Save dataframe to list
  protein_annotations_list[[biosample]] <- protein_annotations
}

```


```{r}

# For each sample, assemble a dataframe of gene information

# Pre-allocate an empty list for gene dataframes
gene_annotations_list <- vector(mode = "list", length = length(metag_ko_unique_df$biosample_id))

for (biosample in 1:1) { #length(metag_ko_unique_df$biosample_id)) {

  # Gather gene annotations from workflow output
  # Join KO and EC annotation dataframes using the NMDC workflow generated "gene_id"
  metag_annotations <- full_join(metag_ko_unique_df$metag_ko_results[[biosample]], 
                                 metag_ec_unique_df$metag_ec_results[[biosample]],
                                 by = join_by("gene_id")) %>%
    distinct(ko_term, EC) %>%
    filter(!is.na(EC)) %>%
    nest(.by = ko_term, .key = "EC") %>%
    rename(ko_id = ko_term, ec_id = EC) %>%
    
    mutate(ko_trimmed = substring(ko_id, 4)) %>%
  
    mutate(In_Metab_Annotations = vapply(.$ec_id, function(x) { any(tolower(x) %in% unique(unlist(metabolite_annotations_list[[biosample]]$ec_id))) },
                             FUN.VALUE = TRUE)) %>%
    mutate(In_Prot_Annotations = ko_id %in% protein_annotations_list[[biosample]]$ko_id)
  
  
  # Get modules for each gene
  # Break up vector of KO IDs, HTTP request URL gets too long
  modules_from_genes <- split(metag_annotations$ko_trimmed, 
                              ceiling(seq_along(metag_annotations$ko_trimmed)/50)) %>%
    lapply(FUN = function(x) { keggLink("module", x) }) %>%
    list_c()
  
  
  modules_from_genes <- data.frame(ko_id = toupper(names(modules_from_genes)),
                                   module_id = modules_from_genes) %>%
    nest(.by = ko_id, .key = "module_id")
  
  
  # Get pathways for each gene
  pathways_from_genes <- split(metag_annotations$ko_trimmed, 
                              ceiling(seq_along(metag_annotations$ko_trimmed)/50)) %>%
    lapply(FUN = function(x) { keggLink("pathway", x) }) %>%
    list_c()
  
  pathways_from_genes <- data.frame(ko_id = toupper(names(pathways_from_genes)),
                                    pathway_id = pathways_from_genes) %>%
    nest(.by = ko_id, .key = "pathway_id")
  
  
  # Add modules and pathways to gene annotations dataframe
  metag_annotations <- metag_annotations %>%
    left_join(modules_from_genes) %>%
    left_join(pathways_from_genes)
  
  gene_annotations_list[[biosample]] <- metag_annotations

}

```

## Visualize shared biomolecule identifications

Generate sector and arc start/end values for the circos plot

```{r circos-counts}

# Select an example biosample
example_gene <- gene_annotations_list[[2]]
example_prot <- protein_annotations_list[[2]]
example_metab <- metabolite_annotations_list[[2]]

# Scale sectors so that arc widths are proportional rather than absolute
# There are way more gene identifications than others so it gets hard to visualize as absolute counts
largest_sector_xlim <- max(length(example_gene$ko_id),
                           length(example_prot$ko_id),
                           length(example_metab$compound_id))

# Gene sector
gene_sector_xlim <- (length(example_gene$ko_id))

gene_sector_prot_count <- (sum(example_gene$In_Prot_Annotations)) * (largest_sector_xlim / gene_sector_xlim)
gene_sector_both_count <- (nrow(filter(example_gene, In_Metab_Annotations & In_Prot_Annotations))) * (largest_sector_xlim / gene_sector_xlim)
gene_sector_metab_count <-(sum(example_gene$In_Metab_Annotations)) * (largest_sector_xlim / gene_sector_xlim)

# Prot sector
prot_sector_xlim <- length(example_prot$ko_id)

prot_sector_metab_count <- sum(example_prot$In_Metab_Annotations) * (largest_sector_xlim / prot_sector_xlim)
prot_sector_both_count <- nrow(filter(example_prot, In_Metab_Annotations & In_Gene_Annotations)) * (largest_sector_xlim / prot_sector_xlim)
prot_sector_gene_count <-sum(example_prot$In_Gene_Annotations) * (largest_sector_xlim / prot_sector_xlim)


# Metab sector
metab_sector_xlim <- length(example_metab$compound_id)

metab_sector_gene_count <- sum(example_metab$In_Metag_Annotations) * (metab_sector_xlim / prot_sector_xlim)
metab_sector_both_count <- nrow(filter(example_metab, In_Metag_Annotations & In_Prot_Annotations)) * (metab_sector_xlim / prot_sector_xlim)
metab_sector_prot_count <-sum(example_metab$In_Prot_Annotations) * (metab_sector_xlim / prot_sector_xlim)

# Reset sector sizes to scaled value
gene_sector_xlim <- largest_sector_xlim
prot_sector_xlim <- largest_sector_xlim
metab_sector_xlim <- largest_sector_xlim


```


Generate a chord diagram showing which biomolecules in each omics type have connections to each other omics type

```{r circos}

plot_sector_names <- c("genes", "proteins", "metabolites")
 
# Create data
data = data.frame(
    sectors = c(rep("genes", gene_sector_xlim),
               rep("proteins", prot_sector_xlim),
               rep("metabolites", metab_sector_xlim)),
    x = c(seq(1:gene_sector_xlim),
          seq(1:prot_sector_xlim),
          seq(1:metab_sector_xlim)),
    y = c(seq(1:gene_sector_xlim),
          seq(1:prot_sector_xlim),
          seq(1:metab_sector_xlim))) %>%
  mutate(sectors = factor(sectors, levels = plot_sector_names))
 
# Initialize the plot.
circos.initialize(factors = data$sectors, x = data$x)

circos.labels(plot_sector_names, 
              x = c(gene_sector_xlim/2, prot_sector_xlim/2, metab_sector_xlim/2), 
              labels = c(paste0("genes (", nrow(metag_annotations), ")"),
                         paste0("proteins (", nrow(prot_annotations), ")"), 
                         paste0("metabolites (", nrow(metabolite_annotations), ")")),
              side = "outside")

 
# Build the regions of track #1
circos.trackPlotRegion(factors = data$sectors, y=data$y, bg.col = c("tomato", "gold", "skyblue2") , bg.border = NA)
 
# Add a link between a zone and another
circos.link("genes", c(0, gene_sector_prot_count), 
            "proteins", c(prot_sector_metab_count - prot_sector_both_count, 
                          prot_sector_metab_count - prot_sector_both_count + prot_sector_gene_count), 
            col = "#ff870099")


circos.link("proteins", c(0, prot_sector_metab_count), 
            "metabolites", c(metab_sector_gene_count - metab_sector_both_count,
                             metab_sector_gene_count - metab_sector_both_count + metab_sector_prot_count), 
            col = "#63ff0099")



circos.link("metabolites", c(0, metab_sector_gene_count), 
            "genes", c(gene_sector_prot_count - gene_sector_both_count,
                       gene_sector_prot_count - gene_sector_both_count + gene_sector_metab_count), 
            col = "#8b24cd99")

```


















###### pathway coverage

```{r}

# Get unique list of pathways from all identified biomolecules
all_pathways <- c(metag_annotations$pathway_id, 
                  prot_annotations$pathway_id,
                  metabolite_annotations$pathway_id) %>%
  unlist(use.names = FALSE) %>%
  unique()

# Look at basic pathway maps, exclude KO highlighted pathway maps
all_pathways <- all_pathways[!str_detect(all_pathways, "path:ko")]

# Exclude "overview" pathway maps
all_pathways <- all_pathways[!str_detect(all_pathways, "path:map01")]



# Get all elements of each pathway

compounds_from_pathways <- split(all_pathways, ceiling(seq_along(all_pathways)/50)) %>%
  lapply(FUN = function(x) { keggLink("compound", x) }) %>%
  list_c()


compounds_from_pathways <- data.frame(pathway_id = names(compounds_from_pathways),
                                      compound_id = compounds_from_pathways) %>%
  nest(.by = pathway_id, .key = "compound_id")


ko_from_pathways <- split(all_pathways, ceiling(seq_along(all_pathways)/50)) %>%
  lapply(FUN = function(x) { keggLink("ko", x) }) %>%
  list_c()


ko_from_pathways <- data.frame(pathway_id = names(ko_from_pathways),
                               ko_id = ko_from_pathways) %>%
  nest(.by = pathway_id, .key = "ko_id")





# Count gene KOs
# Count compounds
# Total number of components of pathway

pathway_stats <- data.frame(pathway_id = all_pathways) %>%
  left_join(compounds_from_pathways) %>%
  left_join(ko_from_pathways) %>%
  mutate(compound_count = vapply(compound_id, 
                                 FUN = function(x) { ifelse(is.null(x), 0, nrow(x)) }, 
                                 FUN.VALUE = 1)) %>%
  mutate(ko_count =       vapply(ko_id, 
                                 FUN = function(x) { ifelse(is.null(x), 0, nrow(x)) }, 
                                 FUN.VALUE = 1))


# Count KOs detected in NMDC data (metag and metap)
all_ko_detected <- unique(c(metag_annotations$ko_id, prot_annotations$ko_id))


# Calculate coverage of pathways

pathway_stats <- pathway_stats %>%
  mutate(compound_coverage = map2_vec(compound_id, compound_count,
    .f = function(x, y) { ifelse(is.null(x), 0, 
             sum(x$compound_id %in% metabolite_annotations$compound_id)/y) }
  )) %>%
  mutate(ko_coverage = map2_vec(ko_id, ko_count,
    .f = function(x, y) { ifelse(is.null(x), 0, 
             sum(toupper(x$ko_id) %in% all_ko_detected)/y) }
  )) %>%
  
  mutate(total_components = compound_count + ko_count,
         total_coverage = (compound_coverage * compound_count + ko_coverage * ko_count)/total_components) %>%
  
  arrange(-total_coverage)



# What are the most covered pathways?
pull(head(pathway_stats, 5), pathway_id)


ggplot(pathway_stats) + 
  geom_point(aes(x = ko_coverage, y = compound_coverage, color = total_coverage)) +
  scale_color_gradient(low = "darkblue", high = "green") +
  coord_equal()


```


####### highest coverage pathways in each sample


```{r heatmap}




```

```{r scatterplot}



```





## Color pathway diagrams

```{r}

"https://www.genome.jp/pathway/map00270+1.8.1.10+1.8.4.3+C00051"

"https://www.genome.jp/module/M00338+K01758"

# color by what % of samples had this gene/protein/metabolite
# maybe just exclude 01 pathways (overviews) and go back to doing pathways

# "glycine, serine, and threonine metabolism"
# this highlights several EC numbers in green
browseURL(mark.pathway.by.objects("path:eco00260", c("eco:b0002", "eco:b0003")))

# "cysteine and methionine metabolism"
# "path:ecxxxxx" highlights almost all the EC numbers in purple ish???
# "path:ecoxxxxx" highlights some EC numbers in green
# "path:mapxxxx" highlights nothing
browseURL(mark.pathway.by.objects("path:map00270", "ec:1.8.1.10"))


# appears identical to the first one but different url
color.pathway.by.objects("path:eco00260", c("eco:b0002", "eco:b0003"), c("#ff0000", "#00ff00"), c("#ffff00","yellow"))

# "cysteine and methionine metabolism"
# no highlights
browseURL(color.pathway.by.objects("map00270", "C00051", "#00FF00", "#0000FF"))



```

```{r}
# mark.pathway.by.objects <- function(pathway.id, object.id.list)


pathway.id <- "map00270"
object.id.list <- c("1.8.1.10", "1.8.4.3", "C00051")

pathway.id <- sub("^path:", "", pathway.id)
object.id.list <- paste(object.id.list, collapse="+")
pathway.id <- sprintf("%s+%s", pathway.id, object.id.list)

url <- sprintf("https://www.kegg.jp/pathway/%s", pathway.id)

res <- GET(url)
stop_for_status(res, "GET KEGG pathway URL")
content <- content(res, type="text", encoding = "UTF-8")
lines <- strsplit(content, "\n", fixed=TRUE)[[1]]
urlLine <- grep("<img src=\"/kegg", lines, value=TRUE)
path <- strsplit(urlLine, '"', fixed=TRUE)[[1]][2]
browseURL(sprintf("https://www.kegg.jp%s", path))

```

```{r}

# color.pathway.by.objects <- function(pathway.id, object.id.list, fg.color.list, bg.color.list)

pathway.id <- "map00270"
object.id.list <- "C00022"
fg.color.list <- "#00FF00"
bg.color.list <- "#0000FF"

pathway.id <- sub("^path:", "", pathway.id)
if (!(length(object.id.list)==length(fg.color.list) &&
      length(fg.color.list) == length(bg.color.list))) {
    stop(paste("object.id.list, fg.color.list, and bg.color.list must",
        "all be the same length."))
}

# format identifier/color list as expected by server
payload <- paste(
    c("#ids", object.id.list),
    c("cols", paste(bg.color.list, fg.color.list, sep=',')),
    sep="\t",
    collapse="\n"
)

# fetch KEGG page from server, via a 302 redirect handled by httr
# transparently
# res <- POST(
#     url = "https://www.kegg.jp/kegg-bin/show_pathway",
#     body = list(
#         map = pathway.id,
#         multi_query = payload,
#         mode = 'color'
#     ),
#     encode="multipart"
# )
res <- GET("https://www.genome.jp/kegg-bin/show_pathway?map00270/c00022%09%2300ff00,0000ff")
res <- content(res, "text")

# extract image URL from page
img_matches <- regexpr(
    "(?<=<img src=\")[^\"]+",
    res,
    perl=T
)
img_url <- regmatches(res, img_matches)
if (length(img_url) < 1) {
    stop(
        "'color.pathway.by.objects()' ",
        "failed to extract KEGG image path from response."
    )
}
if (length(img_url) > 1) {
    stop(
        "'color.pathway.by.objects()' ",
        "unexpectedly matched multiple KEGG image paths in response."
    )
}
browseURL(sprintf("https://www.kegg.jp%s", img_url))





```


```{r}
library(rvest)
library(chromote)

asdf <- read_html_live("https://www.genome.jp/kegg-bin/show_pathway?map00270/c00022%09%2300ff00,0000ff")$html_elements(css = "img")

asdf <- read_html_live("https://www.genome.jp/")$html_elements(css = "img")



url <- "https://www.forbes.com/top-colleges/"
sess <- read_html_live(url)
sess |> 
  html_elements(".TopColleges2023_tableRowGroup__65RHn") |> 
  html_elements(".TopColleges2023_tableRow__BYOSU")

```

