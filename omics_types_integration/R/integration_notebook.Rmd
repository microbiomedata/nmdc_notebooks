---
title: "Untitled"
output: html_document
date: "2024-11-26"
---

This notebook is an example of how different omics data types may be linked via commonly used annotation vocabularies and investigated together. In this notebook we explore biomolecules and KEGG pathways identified in a set of samples that have processed metagenomic, metaproteomics, and metabolomics data available in the NMDC Data Portal.

NOTE: This notebook uses the KEGGREST R package to interface with the KEGG API. Use of the KEGG API and KEGGREST is restricted to academic users. Non-academic users must obtain a commercial license. (See https://www.kegg.jp/kegg/legal.html) The National Microbiome Data Collaborative use of KEGG is covered by license (license information).

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr, warn.conflicts = FALSE)
library(tidyr, warn.conflicts = FALSE)
library(stringr, warn.conflicts = FALSE)
library(readr, warn.conflicts = FALSE)
library(purrr)
library(ggplot2, warn.conflicts = FALSE)
library(tibble)
library(jsonlite)
library(KEGGREST)
library(httr)
library(circlize)
```

## Retrieve data from the NMDC database using API endpoints

### Choose data to retrieve

The NMDC data portal (https://data.microbiomedata.org/) allow us to filter data and samples according to many criteria. In this case, we use the Data Type filters (upset plot) to identify samples that have metagenomics, metaproteomics, and metabolomics data. This returns 33 samples from the study "Riverbed sediment microbial communities from the Columbia River, Washington, USA" (https://data.microbiomedata.org/details/study/nmdc:sty-11-aygzgv51).

### Retrieve and filter data for Columbia River sediment study

The study page linked above has the NMDC study identifier in the URL: `nmdc:sty-11-aygzgv51`. We will use the function `get_data_objects_for_study` (defined in `utility_functions.R`) to retrieve all records that represent data. This includes raw data files (e.g. FASTQ or mass spectra files) as well as processed data results output by the NMDC workflows.

```{r pull-data-object-records}

# Retrieve all data objects associated with this study
dobj <- jsonlite::fromJSON('https://api.microbiomedata.org/data_objects/study/nmdc%3Asty-11-aygzgv51') %>% 
  unnest()
```

In this case, we want to look at the processed data results for our three omics types of interest. Specifically, we want the files containing KEGG Orthology and Enzyme Commission annotations. 

One way of further identifying a NMDC `DataObject` record is by looking at its slot `data_object_type` (https://microbiomedata.github.io/nmdc-schema/data_object_type/), which contains a value from `FileTypeEnum` (https://microbiomedata.github.io/nmdc-schema/FileTypeEnum/). Based on the descriptions of `FileTypeEnum` permissible values we want to filter for results files with the following `data_object_type` values:

| Value | Description |
|:-----:|:-----------:|
|Annotation Enzyme Commission|Tab delimited file for EC annotation|
|Annotation KEGG Orthology|Tab delimited file for KO annotation|
|GC-MS Metabolomics Results|GC-MS-based metabolite assignment results table|
|Protein Report|Filtered protein report file|

```{r filter-data-objects}

dobj <- dobj %>%
  # Filter to biosamples with metagenome EC annotations, metagenome KO 
  # annotations, metaproteomics results, and metabolomics results
  group_by(biosample_id) %>%
  filter("Annotation Enzyme Commission" %in% data_object_type &
           "Annotation KEGG Orthology" %in% data_object_type & 
           "GC-MS Metabolomics Results" %in% data_object_type &
           "Protein Report" %in% data_object_type) %>%
  ungroup() %>%
  
  # Remove uninformative columns for simpler dataframe
  select(-c(alternative_identifiers, in_manifest, was_generated_by))

```
head()
### Download selected results files
 
Now we can use the `url` slot from the filtered `DataObject` records to read in all of the files containing the annotations of interest.

```{r download-results}

results_by_biosample <- dobj %>%
  
  # Filter to desired results file types and create one URL column per type
  filter(data_object_type %in% c("Annotation Enzyme Commission", "Annotation KEGG Orthology",
                                 "GC-MS Metabolomics Results", "Protein Report")) %>%
  select(biosample_id, data_object_type, url) %>%
  pivot_wider(names_from = data_object_type, values_from = url) %>%
  
  # Read in the TSV/CSV results files
  # Add in column names from the IMG genome download README
  mutate(metag_ec_results = lapply(
    .$`Annotation Enzyme Commission`, 
    function(x) { 
      d <- read_tsv(x, col_names = FALSE, show_col_types = FALSE)
      names(d) <- c("gene_id", "img_ko_flag", "EC", "percent_identity",
                    "query_start", "query_end", "subj_start", "subj_end",
                    "evalue", "bit_score", "align_length")
      d
      })) %>%
  
  mutate(metag_ko_results = lapply(
    .$`Annotation KEGG Orthology`, 
    function(x) { 
      d <- read_tsv(x, col_names = FALSE, show_col_types = FALSE)
      names(d) <- c("gene_id", "img_ko_flag", "ko_term", "percent_identity",
                    "query_start", "query_end", "subj_start", "subj_end",
                    "evalue", "bit_score", "align_length")
      d
      })) %>%

  mutate(metap_results = lapply(.$`Protein Report`, read_tsv, col_names = TRUE, show_col_types = FALSE)) %>%
  mutate(metab_results = lapply(.$`GC-MS Metabolomics Results`, read_csv, col_names = TRUE, show_col_types = FALSE))


```

Each of the downloaded data files contains lots of information including the KO, EC, or KEGG Compound identifiers.

```{r}

head(results_by_biosample$metag_ko_results[[1]])

```

From each results table we can extract the unique list of genes/proteins/metabolites identified in that sample.

```{r unique-identifications}

unlist_unique <- function (x) {
  unique(unlist(x, use.names = FALSE))
}

# Metagenome annotations - Enzyme Commission
# metag_ec_unique_df <- results_by_biosample %>%
#   distinct(biosample_id, .keep_all = TRUE) %>%
# 
#   # Save a unique vector of annotations by type for each sample for searching later
#   mutate(metag_ec_unique = lapply(.$metag_ec_results, 
#                                   FUN = function(x) { sort(unique(x$EC)) })) %>%
#   select(biosample_id, metag_ec_results, metag_ec_unique)

# Metaproteome annotations - Enzyme Commission
# metap_ec_unique_df <- results_by_biosample %>%
#   distinct(biosample_id, .keep_all = TRUE) %>%
# 
#   # Save a unique vector of annotations by type for each sample for searching later
#   mutate(metap_ec_unique = lapply(
#     .$metap_results, 
#     FUN = function(x) { sort(unique(x$EC_Number)) %>% strsplit(",") %>% unlist() })) %>%
#   select(biosample_id, metap_results, metap_ec_unique)

# Metabolome annotations - KEGG Compound

# metab_ko_unique_df <- results_by_biosample %>%
#   distinct(biosample_id, .keep_all = TRUE) %>%
# 
#   # Save a unique vector of annotations by type for each sample for searching later
#   mutate(metab_ko_unique = lapply(.$metab_results, 
#                                   FUN = function(x) { sort(unique(x$`Kegg Compound ID`)) })) %>%
#   select(biosample_id, metab_results, metab_ko_unique)

```

## Get IDs from other KEGG databases

Now we will use the KEGGREST package (available on Bioconductor) to make calls to the KEGG API. Using the annotations provided in the workflow results, we can look up the corresponding annotations in other KEGG databases to start drawing connections between biomolecule identifications.

### Gather metabolite information

First we will find all of the Enzyme Commission numbers available for each identified compound. These EC numbers represent enzymes involved in recorded reactions that produce the compound of interest.

```{r get-other-metabolite-info}

metab_co_unique_list <- results_by_biosample$metab_results %>%
  lapply(FUN = function(x) { sort(unique(x$`Kegg Compound ID`)) }) %>%
  setNames(results_by_biosample$biosample_id)

metab_co_unique <- unlist_unique(metab_co_unique_list)


# Concatenate the metabolites, make all the calls once, then split up by biosample

# Get all EC ids for each compound
ec_from_metabolites <- metab_co_unique %>%
  split(ceiling(seq_along(.)/50)) %>%
  lapply(FUN = function(x) { Sys.sleep(0.5); keggLink("enzyme", x) }) %>%
  list_c()
  
# Format into a nested dataframe
ec_from_metabolites <- data.frame(compound_id = names(ec_from_metabolites),
                                  ec_id = ec_from_metabolites) %>%
  nest(.by = compound_id, .key = "ec_id")


# Get all module ids for each compound
modules_from_metabolites <- metab_co_unique %>%
  split(ceiling(seq_along(.)/50)) %>%
  lapply(FUN = function(x) { Sys.sleep(0.5); keggLink("module", x) }) %>%
  list_c()
  
# Format into a nested dataframe
modules_from_metabolites <- data.frame(compound_id = names(modules_from_metabolites),
                                       module_id = modules_from_metabolites) %>%
  nest(.by = compound_id, .key = "module_id")


# Get all pathway ids for each compound
pathways_from_metabolites <- metab_co_unique %>%
  split(ceiling(seq_along(.)/50)) %>%
  lapply(FUN = function(x) { Sys.sleep(0.5); keggLink("pathway", x) }) %>%
  list_c()
  
# Format into a nested dataframe
pathways_from_metabolites <- data.frame(compound_id = names(pathways_from_metabolites),
                                        pathway_id = pathways_from_metabolites) %>%
  nest(.by = compound_id, .key = "pathway_id")


# Assemble
metabolite_annotations <- data.frame(compound_id = paste0("cpd:", metab_co_unique),
                                     compound_trimmed = metab_co_unique) %>%
  left_join(ec_from_metabolites, by = join_by(compound_id)) %>%
  left_join(modules_from_metabolites, by = join_by(compound_id)) %>%
  left_join(pathways_from_metabolites, by = join_by(compound_id))


# Pre-allocate an empty list for metabolite dataframes
metabolite_annotations_list <- vector(mode = "list", length = nrow(results_by_biosample))

for (biosample in 1:nrow(results_by_biosample)) {
  
  # For each sample, assemble a dataframe of metabolite information
  # Start with the unique list of metabolites for this sample
  metabolite_annotations_list[[biosample]] <- data.frame(compound_id = paste0("cpd:", metab_co_unique_list[[biosample]])) %>%
    # Filter join all metabolite annotations down to just the ones in this sample
    left_join(metabolite_annotations, by = join_by(compound_id))
}

rm(metabolite_annotations, ec_from_metabolites, modules_from_metabolites, pathways_from_metabolites, metab_co_unique, metab_co_unique_list)

```

```{r, eval = FALSE}









for (biosample in 1:33) {

  unique_metabolites <- metab_ko_unique_df$metab_ko_unique[[biosample]]

  # Get EC ids for each metabolite
  ec_from_metabolites <- keggLink("enzyme", unique_metabolites)

  ec_from_metabolites <- data.frame(compound_id = names(ec_from_metabolites),
                                    ec_id = ec_from_metabolites) %>%
    nest(.by = compound_id, .key = "ec_id")

  # Get modules for each metabolite
  modules_from_metabolites <- keggLink("module", unique_metabolites)

  modules_from_metabolites <- data.frame(compound_id = names(modules_from_metabolites),
                                        module_id = modules_from_metabolites) %>%
    nest(.by = compound_id, .key = "module_id")


  # Get pathways for each metabolite
  pathways_from_metabolites <- keggLink("pathway", unique_metabolites)

  pathways_from_metabolites <- data.frame(compound_id = names(pathways_from_metabolites),
                                          pathway_id = pathways_from_metabolites) %>%
    nest(.by = compound_id, .key = "pathway_id")

  # Join compound, EC, module, pathway IDs into one dataframe
  metabolite_annotations <- data.frame(compound_id = paste0("cpd:", unique_metabolites)) %>%
    left_join(ec_from_metabolites, by = join_by(compound_id)) %>%
    left_join(modules_from_metabolites, by = join_by(compound_id)) %>%
    left_join(pathways_from_metabolites, by = join_by(compound_id)) %>%
    mutate(compound_trimmed = unique_metabolites) %>%
    
    # Search for the EC IDs in the unique identification lists 
    # for the other biomolecules in this sample
    mutate(In_Metag_Annotations = vapply(.$ec_id, function(x) { any(x$ec_id %in% tolower(metag_ec_unique_df$metag_ec_unique[[biosample]])) },
                            FUN.VALUE = TRUE)) %>%
    mutate(In_Prot_Annotations = vapply(.$ec_id, function(x) { any(x$ec_id %in% tolower(metap_ec_unique_df$metap_ec_unique[[biosample]])) },
                            FUN.VALUE = TRUE))

  # Save dataframe to list
  metabolite_annotations_list[[biosample]] <- metabolite_annotations
  
  # Wait for 1 second to avoid KEGG REST API limits
  Sys.sleep(1)
}
```

```{r get-other-protein-info}



metap_ko_unique_list <- results_by_biosample$metap_results %>%
  lapply(FUN = function(x) { sort(unique(x$KO)) }) %>%
  setNames(results_by_biosample$biosample_id)

metap_ko_unique <- unlist_unique(metap_ko_unique_list)


metap_ec_unique_list <- results_by_biosample$metap_results %>%
  lapply(FUN = function(x) { x$EC_Number %>% strsplit(",") %>% unlist_unique() %>% sort() }) %>%
  setNames(results_by_biosample$biosample_id)

metap_ec_unique <- unlist_unique(metap_ec_unique_list)

metap_combined_unique <- results_by_biosample$metap_results %>%
  bind_rows() %>%
  select(KO, EC_Number) %>%
  rename(ec_id = "EC_Number",
         ko_id = "KO") %>%
  separate_wider_delim(ec_id, delim = ",", names_sep = ".", too_few = "align_start") %>%
  pivot_longer(cols = starts_with("ec_id"), names_to = NULL, values_to = "ec_id") %>%
  filter(if_any(everything(), ~ !is.na(.))) %>%
  group_by(ko_id) %>%
  mutate(has_value = any(!is.na(ec_id))) %>%
  ungroup() %>%
  # filter OUT rows where has value is TRUE and ec is NA
  filter(!(has_value & is.na(ec_id))) %>%
  select(-has_value) %>%
  distinct()





# Concatenate the proteins, make all the calls once, then split up by biosample

# Get all module ids for each protein
modules_from_proteins <- metap_ko_unique %>%
  substring(4) %>%
  split(ceiling(seq_along(.)/50)) %>%
  lapply(FUN = function(x) { Sys.sleep(0.5); keggLink("module", x) }) %>%
  list_c()
  
# Format into a nested dataframe
modules_from_proteins <- data.frame(ko_id = toupper(names(modules_from_proteins)),
                                    module_id = modules_from_proteins) %>%
  nest(.by = ko_id, .key = "module_id")


# Get all pathway ids for each protein
pathways_from_proteins <- metap_ko_unique %>%
  substring(4) %>%
  split(ceiling(seq_along(.)/50)) %>%
  lapply(FUN = function(x) { Sys.sleep(0.5); keggLink("pathway", x) }) %>%
  list_c()
  
# Format into a nested dataframe
pathways_from_proteins <- data.frame(ko_id = toupper(names(pathways_from_proteins)),
                                     pathway_id = pathways_from_proteins) %>%
  nest(.by = ko_id, .key = "pathway_id")


# Assemble
protein_annotations <- metap_combined_unique %>%
  left_join(modules_from_proteins, by = join_by(ko_id)) %>%
  left_join(pathways_from_proteins, by = join_by(ko_id))


# Pre-allocate an empty list for protein dataframes
protein_annotations_list <- vector(mode = "list", length = nrow(results_by_biosample))

for (biosample in 1:nrow(results_by_biosample)) {
  
  # For each sample, assemble a dataframe of protein information
  # Start with the unique list of proteins for this sample
  protein_annotations_list[[biosample]] <- data.frame(ko_id = metap_ko_unique_list[[biosample]]) %>%
    # Filter join all metabolite annotations down to just the ones in this sample
    left_join(protein_annotations, by = join_by(ko_id))
}

rm(protein_annotations, modules_from_proteins, pathways_from_proteins, metap_ec_unique_list, metap_ko_unique_list, metap_combined_unique, metap_ec_unique, metap_ko_unique)

```

```{r, eval = FALSE}

# For each sample, assemble a dataframe of protein information

# Pre-allocate an empty list for protein dataframes
protein_annotations_list <- vector(mode = "list", length = length(metap_ec_unique_df$biosample_id))

for (biosample in 1:length(metap_ec_unique_df$biosample_id)) {

  # Gather protein annotations from workflow output
  protein_annotations <- metap_ec_unique_df$metap_results[[biosample]] %>%
    select(KO, EC_Number) %>%
    rename(ko_id = KO, ec_id = EC_Number) %>%
    mutate(ec_id = trimws(strsplit(ec_id, ","))) %>%
    filter(if_any(everything(), ~ !is.na(.))) %>%
    distinct() %>%
    mutate(ko_trimmed = substring(ko_id, 4))
  
  unique_proteins <- protein_annotations$ko_trimmed
  
  # Get modules for each protein
  modules_from_proteins <- keggLink("module", unique_proteins)
  
  modules_from_proteins <- data.frame(ko_id = toupper(names(modules_from_proteins)),
                                      module_id = modules_from_proteins) %>%
    nest(.by = ko_id, .key = "module_id")
  
  
  # Get pathways for each protein
  pathways_from_proteins <- keggLink("pathway", unique_proteins)
  
  pathways_from_proteins <- data.frame(ko_id = toupper(names(pathways_from_proteins)),
                                       pathway_id = pathways_from_proteins) %>%
    nest(.by = ko_id, .key = "pathway_id")

  
  # Join KO, EC, module, pathway IDs into one dataframe
  protein_annotations <- protein_annotations %>%
    left_join(modules_from_proteins, by = join_by(ko_id)) %>%
    left_join(pathways_from_proteins, by = join_by(ko_id)) %>%
    
    # Search for corresponding biomolecules in other data types for this sample
    mutate(In_Metab_Annotations = vapply(.$ec_id, function(x) { any(tolower(x) %in% unique(unlist(metabolite_annotations_list[[biosample]]$ec_id))) },
                                         FUN.VALUE = TRUE)) %>%
    mutate(In_Metag_Annotations = vapply(.$ko_id, function(x) { any(x %in% unique(metag_ko_unique_df$metag_ko_unique[[biosample]])) },
                                         FUN.VALUE = TRUE))
  
  # Save dataframe to list
  protein_annotations_list[[biosample]] <- protein_annotations
  
  # Wait for 1 second to avoid KEGG REST API limits
  Sys.sleep(1)
}

```

```{r get-other-gene-info}


# metag_ec_unique_list <- results_by_biosample$metag_ec_results %>%
#   lapply(FUN = function(x) { sort(unique(x$EC)) }) %>%
#   setNames(results_by_biosample$biosample_id)
# 
# metag_ec_unique <- unlist_unique(metag_ec_unique_list)



metag_ko_unique_list <- results_by_biosample$metag_ko_results %>%
  lapply(FUN = function(x) { sort(unique(x$ko_term)) }) %>%
  setNames(results_by_biosample$biosample_id)

metag_ko_unique <- unlist_unique(metag_ko_unique_list)






# Concatenate the genes, make all the calls once, then split up by biosample

# Get all module ids for each gene
modules_from_genes <- metag_ko_unique %>%
  substring(4) %>%
  split(ceiling(seq_along(.)/50)) %>%
  lapply(FUN = function(x) { Sys.sleep(0.5); keggLink("module", x) }) %>%
  list_c()
  
# Format into a nested dataframe
modules_from_genes <- data.frame(ko_id = toupper(names(modules_from_genes)),
                                 module_id = modules_from_genes) %>%
  nest(.by = ko_id, .key = "module_id")


# Get all pathway ids for each gene
pathways_from_genes <- metag_ko_unique %>%
  substring(4) %>%
  split(ceiling(seq_along(.)/50)) %>%
  lapply(FUN = function(x) { Sys.sleep(0.5); keggLink("pathway", x) }) %>%
  list_c()
  
# Format into a nested dataframe
pathways_from_genes <- data.frame(ko_id = toupper(names(pathways_from_genes)),
                                  pathway_id = pathways_from_genes) %>%
  nest(.by = ko_id, .key = "pathway_id")


# Assemble
gene_annotations <- data.frame(ko_id = metag_ko_unique) %>%
  left_join(modules_from_genes, by = join_by(ko_id)) %>%
  left_join(pathways_from_genes, by = join_by(ko_id))


# Pre-allocate an empty list for gene dataframes
gene_annotations_list <- vector(mode = "list", length = nrow(results_by_biosample))

for (biosample in 1:nrow(results_by_biosample)) {
  
  # Add in the EC annotations here - it will be easier since they are in a separate file per sample
  
  # For each sample, assemble a dataframe of gene information

  # Start by pairing the KO and EC information from the annotation results files
  gene_annotations_list[[biosample]] <- results_by_biosample$metag_ko_results[[biosample]] %>%
    full_join(results_by_biosample$metag_ec_results[[biosample]],
              by = join_by(gene_id)) %>%
    select(ko_term, EC) %>%
    distinct() %>%
    rename(ko_id = "ko_term",
           ec_id = "EC") %>%
    
    # Now filter join all gene annotations down to just the ones in this sample
    left_join(gene_annotations, by = join_by(ko_id))
}

rm(gene_annotations, modules_from_genes, pathways_from_genes, metag_ko_unique, metag_ko_unique_list)


```

```{r, eval = FALSE}

# For each sample, assemble a dataframe of gene information

# Pre-allocate an empty list for gene dataframes
gene_annotations_list <- vector(mode = "list", length = length(metag_ko_unique_df$biosample_id))

for (biosample in 1:length(metag_ko_unique_df$biosample_id)) {

  # Gather gene annotations from workflow output
  # Join KO and EC annotation dataframes using the NMDC workflow generated "gene_id"
  metag_annotations <- full_join(metag_ko_unique_df$metag_ko_results[[biosample]], 
                                 metag_ec_unique_df$metag_ec_results[[biosample]],
                                 by = join_by("gene_id")) %>%
    distinct(ko_term, EC) %>%
    filter(!is.na(EC)) %>%
    nest(.by = ko_term, .key = "EC") %>%
    rename(ko_id = ko_term, ec_id = EC) %>%
    
    mutate(ko_trimmed = substring(ko_id, 4)) %>%
  
    mutate(In_Metab_Annotations = vapply(.$ec_id, function(x) { any(tolower(x) %in% unique(unlist(metabolite_annotations_list[[biosample]]$ec_id))) },
                             FUN.VALUE = TRUE)) %>%
    mutate(In_Prot_Annotations = ko_id %in% protein_annotations_list[[biosample]]$ko_id)
  
  
  # Get modules for each gene
  # Break up vector of KO IDs, HTTP request URL gets too long
  modules_from_genes <- split(metag_annotations$ko_trimmed, 
                              ceiling(seq_along(metag_annotations$ko_trimmed)/50)) %>%
    lapply(FUN = function(x) { keggLink("module", x) }) %>%
    list_c()
  
  
  modules_from_genes <- data.frame(ko_id = toupper(names(modules_from_genes)),
                                   module_id = modules_from_genes) %>%
    nest(.by = ko_id, .key = "module_id")
  
  
  # Get pathways for each gene
  pathways_from_genes <- split(metag_annotations$ko_trimmed, 
                              ceiling(seq_along(metag_annotations$ko_trimmed)/50)) %>%
    lapply(FUN = function(x) { keggLink("pathway", x) }) %>%
    list_c()
  
  pathways_from_genes <- data.frame(ko_id = toupper(names(pathways_from_genes)),
                                    pathway_id = pathways_from_genes) %>%
    nest(.by = ko_id, .key = "pathway_id")
  
  
  # Add modules and pathways to gene annotations dataframe
  metag_annotations <- metag_annotations %>%
    left_join(modules_from_genes, by = join_by(ko_id)) %>%
    left_join(pathways_from_genes, by = join_by(ko_id))
  
  
  gene_annotations_list[[biosample]] <- metag_annotations
  
  # Wait for 1 second to avoid KEGG REST API limits
  Sys.sleep(1)

}

```


```{r overlap}
# Add "is this x in y" columns for all biomolecules

for (biosample in 1:nrow(results_by_biosample)) {
  
  metabolite_annotations_list[[biosample]] <- metabolite_annotations_list[[biosample]] %>%
    
    # The EC ID column in metabolite annotations is actually a list of character vectors,
    # since each compound (row) can have multiple EC annotations
    mutate(In_Metag_Annotations = vapply(.$ec_id, function(x) { any(x$ec_id %in% tolower(gene_annotations_list[[biosample]]$ec_id)) },
                            FUN.VALUE = TRUE),
           In_Prot_Annotations = vapply(.$ec_id, function(x) { any(x$ec_id %in% tolower(protein_annotations_list[[biosample]]$ec_id)) },
                            FUN.VALUE = TRUE))
  
  protein_annotations_list[[biosample]] <- protein_annotations_list[[biosample]] %>% 
    # tolower() is needed because the KEGG output has lowercase prefixes
    mutate(In_Metab_Annotations = tolower(ec_id) %in% unlist_unique(metabolite_annotations_list[[biosample]]$ec_id),
           In_Metag_Annotations = ko_id %in% gene_annotations_list[[biosample]]$ko_id)
  
  gene_annotations_list[[biosample]] <- gene_annotations_list[[biosample]] %>%
    mutate(In_Metab_Annotations = tolower(ec_id) %in% unlist_unique(metabolite_annotations_list[[biosample]]$ec_id),
           In_Prot_Annotations = ko_id %in% protein_annotations_list[[biosample]]$ko_id)
}

```



## Visualize shared biomolecule identifications

Generate sector and arc start/end values for the circos plot

```{r circos-counts}

# Select an example biosample
example_gene <- gene_annotations_list[[2]]
example_prot <- protein_annotations_list[[2]]
example_metab <- metabolite_annotations_list[[2]]

# Scale sectors so that arc widths are proportional rather than absolute
# There are way more gene identifications than others so it gets hard to visualize as absolute counts
largest_sector_xlim <- max(length(example_gene$ko_id),
                           length(example_prot$ko_id),
                           length(example_metab$compound_id))

# Gene sector
gene_sector_xlim <- (length(example_gene$ko_id))

gene_sector_prot_count <- (sum(example_gene$In_Prot_Annotations)) * (largest_sector_xlim / gene_sector_xlim)
gene_sector_both_count <- (nrow(filter(example_gene, In_Metab_Annotations & In_Prot_Annotations))) * (largest_sector_xlim / gene_sector_xlim)
gene_sector_metab_count <-(sum(example_gene$In_Metab_Annotations)) * (largest_sector_xlim / gene_sector_xlim)

# Prot sector
prot_sector_xlim <- length(example_prot$ko_id)

prot_sector_metab_count <- sum(example_prot$In_Metab_Annotations) * (largest_sector_xlim / prot_sector_xlim)
prot_sector_both_count <- nrow(filter(example_prot, In_Metab_Annotations & In_Metag_Annotations)) * (largest_sector_xlim / prot_sector_xlim)
prot_sector_gene_count <-sum(example_prot$In_Metag_Annotations) * (largest_sector_xlim / prot_sector_xlim)


# Metab sector
metab_sector_xlim <- length(example_metab$compound_id)

metab_sector_gene_count <- sum(example_metab$In_Metag_Annotations) * (metab_sector_xlim / prot_sector_xlim)
metab_sector_both_count <- nrow(filter(example_metab, In_Metag_Annotations & In_Prot_Annotations)) * (metab_sector_xlim / prot_sector_xlim)
metab_sector_prot_count <-sum(example_metab$In_Prot_Annotations) * (metab_sector_xlim / prot_sector_xlim)

# Reset sector sizes to scaled value
gene_sector_xlim <- largest_sector_xlim
prot_sector_xlim <- largest_sector_xlim
metab_sector_xlim <- largest_sector_xlim


```


Generate a chord diagram showing which biomolecules in each omics type have connections to each other omics type

```{r circos}

plot_sector_names <- c("genes", "proteins", "metabolites")
 
# Create data
data = data.frame(
    sectors = c(rep("genes", gene_sector_xlim),
               rep("proteins", prot_sector_xlim),
               rep("metabolites", metab_sector_xlim)),
    x = c(seq(1:gene_sector_xlim),
          seq(1:prot_sector_xlim),
          seq(1:metab_sector_xlim)),
    y = c(seq(1:gene_sector_xlim),
          seq(1:prot_sector_xlim),
          seq(1:metab_sector_xlim))) %>%
  mutate(sectors = factor(sectors, levels = plot_sector_names))
 
# Initialize the plot.
circos.initialize(factors = data$sectors, x = data$x)

circos.labels(plot_sector_names, 
              x = c(gene_sector_xlim/2, prot_sector_xlim/2, metab_sector_xlim/2), 
              labels = c(paste0("genes (", nrow(example_gene), ")"),
                         paste0("proteins (", nrow(example_prot), ")"), 
                         paste0("metabolites (", nrow(example_metab), ")")),
              side = "outside")

 
# Build the regions of track #1
circos.trackPlotRegion(factors = data$sectors, y=data$y, bg.col = c("tomato", "gold", "skyblue2") , bg.border = NA)
 
# Add a link between a zone and another
circos.link("genes", c(0, gene_sector_prot_count), 
            "proteins", c(prot_sector_metab_count - prot_sector_both_count, 
                          prot_sector_metab_count - prot_sector_both_count + prot_sector_gene_count), 
            col = "#ff870099")


circos.link("proteins", c(0, prot_sector_metab_count), 
            "metabolites", c(metab_sector_gene_count - metab_sector_both_count,
                             metab_sector_gene_count - metab_sector_both_count + metab_sector_prot_count), 
            col = "#63ff0099")



circos.link("metabolites", c(0, metab_sector_gene_count), 
            "genes", c(gene_sector_prot_count - gene_sector_both_count,
                       gene_sector_prot_count - gene_sector_both_count + gene_sector_metab_count), 
            col = "#8b24cd99")

```






###### pathway coverage

```{r}
# Assemble a list of all pathway IDs that any biomolecules in the sample map to

pathways_by_biosample <- vector(mode = "list", length = nrow(results_by_biosample))

for (biosample in 1:length(pathways_by_biosample)) {

  # Get unique list of pathways from all identified biomolecules
  sample_pathways <- c(gene_annotations_list[[biosample]]$pathway_id, 
                       protein_annotations_list[[biosample]]$pathway_id,
                       metabolite_annotations_list[[biosample]]$pathway_id) %>%
    unlist(use.names = FALSE) %>%
    unique()
  
  # Look at basic pathway maps, exclude KO highlighted pathway maps
  sample_pathways <- sample_pathways[!str_detect(sample_pathways, "path:ko")]
  
  # Exclude "overview" pathway maps
  sample_pathways <- sample_pathways[!str_detect(sample_pathways, "path:map01")]
  
  pathways_by_biosample[[biosample]] <- sample_pathways
  
}
```

```{r}

# Get all elements of each pathway (KO and compounds only - EC ids in pathways just highlight the corresponding KO element)

# concatenate the pathways, make all the calls once, then join to pathways by biosample

# Get all compounds for each pathway
compounds_from_pathways <- pathways_by_biosample %>%
  unlist(use.names = FALSE) %>%
  unique() %>%
  split(ceiling(seq_along(.)/50)) %>%
  lapply(FUN = function(x) { keggLink("compound", x) }) %>%
  list_c()
  
# Format into a nested dataframe
compounds_from_pathways <- data.frame(pathway_id = names(compounds_from_pathways),
                                      compound_id = compounds_from_pathways) %>%
  nest(.by = pathway_id, .key = "compound_id")
  
  
  
# Get all KO for each pathway
ko_from_pathways <- pathways_by_biosample %>%
  unlist(use.names = FALSE) %>%
  unique() %>%
  split(ceiling(seq_along(.)/50)) %>%
  lapply(FUN = function(x) { keggLink("ko", x) }) %>%
  list_c()

# Format into a nested dataframe
ko_from_pathways <- data.frame(pathway_id = names(ko_from_pathways),
                               ko_id = ko_from_pathways) %>%
  nest(.by = pathway_id, .key = "ko_id")


# Count gene KOs
# Count compounds

all_pathway_elements <- full_join(compounds_from_pathways, ko_from_pathways, 
                                  by = join_by(pathway_id)) %>%
  mutate(compound_count = vapply(compound_id, 
                                 FUN = function(x) { ifelse(is.null(x), 0, nrow(x)) }, 
                                 FUN.VALUE = 1)) %>%
  mutate(ko_count =       vapply(ko_id, 
                                 FUN = function(x) { ifelse(is.null(x), 0, nrow(x)) }, 
                                 FUN.VALUE = 1)) %>%
  mutate(total_elements = compound_count + ko_count)

```



```{r}

pathway_coverage_by_biosample <- vector(mode = "list", length = nrow(results_by_biosample))

for (biosample in 1:length(pathways_by_biosample)) {
  
  all_ko_detected <- unique(c(gene_annotations_list[[biosample]]$ko_id,
                              protein_annotations_list[[biosample]]$ko_id))
  
  pathway_coverage_by_biosample[[biosample]] <- all_pathway_elements %>%
    filter(pathway_id %in% pathways_by_biosample[[biosample]]) %>%
    mutate(compound_found    = vapply(.$compound_id, 
                                      function(x) { sum(x$compound_id %in% metabolite_annotations_list[[biosample]]$compound_id) }, 
                                      FUN.VALUE = 1),
           ko_found          = vapply(.$ko_id, 
                                      function(x) { sum(toupper(x$ko_id) %in% all_ko_detected) }, 
                                      FUN.VALUE = 1),
           compound_coverage = compound_found / compound_count,
           ko_coverage       = ko_found / ko_count,
           total_coverage    = (compound_found + ko_found)/total_elements) %>%
    
    dplyr::select(-c(compound_id, ko_id)) %>%
    mutate(across(where(is.numeric), function(x) ifelse(is.nan(x), NA, x))) %>%
    
    # Filter out pathways where we only found 1 element
    filter(compound_found + ko_found > 1) %>%
    arrange(-total_coverage)
}

```

```{r}

# What are the most covered pathways?
pull(head(pathway_coverage_by_biosample[[1]], 5), pathway_id)


ggplot(pathway_coverage_by_biosample[[1]]) + 
  geom_point(aes(x = ko_coverage, y = compound_coverage, color = total_coverage)) +
  scale_color_gradient(low = "darkblue", high = "green") +
  coord_equal()


```


####### highest coverage pathways in each sample


```{r heatmap}

# sample vs. pathway
# color by coverage

options(repr.plot.width = 7, repr.plot.height = 5, repr.plot.res = 250)
par(xpd = TRUE)

pathway_coverage_by_biosample %>%
  bind_rows(.id = "biosample") %>%
  dplyr::select(biosample, pathway_id, total_coverage) %>%
  pivot_wider(names_from = "pathway_id", values_from = "total_coverage") %>%
  replace(is.na(.), 0) %>%
  column_to_rownames(var = "biosample") %>%
  as.matrix() %>%
  
  heatmap(Rowv = NA, Colv = NA,
          labRow = FALSE, labCol = FALSE, scale = "none",
          main = "KEGG pathway coverage across biosamples",
          xlab = "KEGG Pathways",
          ylab = "Biosamples", 
          keep.dendro = FALSE, na.rm= TRUE,
          col = hcl.colors(50))

par(cex = 0.8)

legend(x = "bottomright", legend = c("Low coverage", "High coverage"), fill = c("#440154", "#FDE725"), inset = c(0, -0.2))


# biosample_metadata <- get_results_by_id(collection = "biosample_set",
#                   match_id_field = "id",
#                   id_list = results_by_biosample$biosample_id,
#                   fields = "id,samp_name,description,collection_date.has_raw_value,depth.has_numeric_value,lat_lon") %>% unnest(names_sep = ".")

```

```{r scatterplot}

pathway_coverage_by_biosample %>%
  bind_rows(.id = "biosample") %>%
  select(biosample, pathway_id, total_coverage) %>%
  group_by(pathway_id) %>%
  filter(any(total_coverage > 0.5)) %>%
  mutate(average_coverage = mean(total_coverage)) %>%
  ungroup() %>%
  arrange(-average_coverage) %>%
  mutate(pathway_id = factor(pathway_id, levels = unique(pathway_id))) %>%
  
  ggplot() +
  geom_violin(aes(x = pathway_id, y = total_coverage)) +
  geom_jitter(aes(x = pathway_id, y = total_coverage)) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

# now we see what pathways are in the plot, do it again with better labelling

top_pathways <- data.frame(
  pathway_id = c("path:map00571", "path:map00710", "path:map00020", "path:map00220", "path:map00770",
                 "path:map00250", "path:map00260", "path:map04122", "path:map00010"),
  pathway_category = c("1.7 Glycan biosynthesis and metabolism", "1.2 Energy metabolism",
                       "1.1 Carbohydrate metabolism", "1.5 Amino acid metabolism", 
                       "1.8 Metabolism of cofactors and vitamins", "1.5 Amino acid metabolism",
                       "1.5 Amino acid metabolism", "2.3 Folding, sorting, and degradation",
                       "1.1 Carbohydrate metabolism"),
  pathway_name = c("Lipoarabinomannan (LAM) biosynthesis", "Carbon fixation by Calvin cycle", 
                   "Citrate cycle (TCA cycle)", "Arginine biosynthesis", "Pantothenate and CoA biosynthesis",
                   "Alanine, aspartate and glutamate metabolism", "Glycine, serine and threonine metabolism",
                   "Sulfur relay system", "Gluconeogenesis"))


pathway_coverage_by_biosample %>%
  bind_rows(.id = "biosample") %>%
  select(biosample, pathway_id, total_coverage) %>%
  group_by(pathway_id) %>%
  filter(any(total_coverage > 0.5)) %>%
  mutate(average_coverage = mean(total_coverage)) %>%
  ungroup() %>%
  arrange(-average_coverage) %>%
  left_join(top_pathways, by = join_by(pathway_id)) %>%
  mutate(pathway_name = factor(pathway_name, levels = unique(pathway_name))) %>%
  
  ggplot() +
  geom_violin(aes(x = pathway_name, y = total_coverage, fill = pathway_category)) +
  geom_jitter(aes(x = pathway_name, y = total_coverage), shape = ".") +
  labs(fill = "Pathway Category") +
  theme(axis.text.x = element_text(angle = 40, vjust = 1, hjust=1),
        axis.title.x = element_blank(),
        legend.position = "left",
        legend.text = element_text(size = 8))

  

# 00571 1.7 Glycan biosynthesis and metabolism / Lipoarabinomannan (LAM) biosynthesis
# 00710 1.2 Energy metabolism / Carbon fixation by Calvin cycle
# 00020 1.1 Carbohydrate metabolism / Citrate cycle (TCA cycle)
# 00220 1.5 Amino acid metabolism / Arginine biosynthesis
# 00770 1.8 Metabolism of cofactors and vitamins / Pantothenate and CoA biosynthesis
# 00250 1.5 Amino acid metabolism / Alanine, aspartate and glutamate metabolism
# 00260 1.5 Amino acid metabolism / Glycine, serine and threonine metabolism
# 04122 2.3 Folding, sorting, and degradation / Sulfur relay system
# 00010 1.1 Carbohydrate metabolism / Glycolysis / Gluconeogenesis


```





## Color pathway diagrams


```{r}

# Select a pathway ID
pathway_detail_id <- "path:map00710"

# Create a vector of KO and compound IDs for the selected pathway, using the query results from earlier
pathway_detail_elements <- c(
  all_pathway_elements[which(all_pathway_elements$pathway_id == pathway_detail_id), 2],
  all_pathway_elements[which(all_pathway_elements$pathway_id == pathway_detail_id), 3]) %>% 
  unlist(use.names = FALSE)

# Pull out pathway elements for each sample
pathway_detail_identifications <- vector(mode = "list", length = nrow(results_by_biosample))

for (biosample in 1:length(pathway_detail_identifications)) {
  
  all_detections <- unique(c(gene_annotations_list[[biosample]]$ko_id,
                             protein_annotations_list[[biosample]]$ko_id,
                             metabolite_annotations_list[[biosample]]$compound_id))
  
  pathway_detail_identifications[[biosample]] <- data.frame(
    biomolecules = all_detections[toupper(all_detections) %in% toupper(pathway_detail_elements)])

}

# Count how many samples each pathway biomolecule appeared in
pathway_detail_identifications <- pathway_detail_identifications %>%
  bind_rows(.id = "biosample") %>%
  group_by(biomolecules) %>%
  summarize(sample_frequency = n()) %>% 
  ungroup() %>%
  mutate(sample_frequency = sample_frequency/length(pathway_detail_identifications)) %>%
  mutate(biomolecules = str_match(biomolecules, ":(.+)$")[,2])

pathway_detail_identifications <- pull(pathway_detail_identifications) %>%
  setNames(pathway_detail_identifications$biomolecules)
    

# Save a colored KEGG pathway map to the working folder
pathview(
  gene.data = pathway_detail_identifications[which(str_detect(names(pathway_detail_identifications), "K"))],
  cpd.data = pathway_detail_identifications[which(str_detect(names(pathway_detail_identifications), "C"))],
  pathway.id = str_match(pathway_detail_id, ":map(.+)$")[,2],
  species = "ko",
  kegg.native = TRUE,
  same.layer = TRUE,
  limit = list(gene = c(0, 1), cpd = c(0, 1)),
  bins = 14,
  low=list(gene="cadetblue"),
  mid = list(gene = "goldenrod"),
  high=list(gene="palevioletred"),
  key.align = "y"
)

```


```{r}

"https://www.genome.jp/pathway/map00270+1.8.1.10+1.8.4.3+C00051"

"https://www.genome.jp/module/M00338+K01758"

# color by what % of samples had this gene/protein/metabolite
# maybe just exclude 01 pathways (overviews) and go back to doing pathways

# "glycine, serine, and threonine metabolism"
# this highlights several EC numbers in green
browseURL(mark.pathway.by.objects("path:eco00260", c("eco:b0002", "eco:b0003")))

# "cysteine and methionine metabolism"
# "path:ecxxxxx" highlights almost all the EC numbers in purple ish???
# "path:ecoxxxxx" highlights some EC numbers in green
# "path:mapxxxx" highlights nothing
browseURL(mark.pathway.by.objects("path:map00270", "ec:1.8.1.10"))


# appears identical to the first one but different url
color.pathway.by.objects("path:eco00260", c("eco:b0002", "eco:b0003"), c("#ff0000", "#00ff00"), c("#ffff00","yellow"))

# "cysteine and methionine metabolism"
# no highlights
browseURL(color.pathway.by.objects("map00270", "C00051", "#00FF00", "#0000FF"))



```

```{r}
# mark.pathway.by.objects <- function(pathway.id, object.id.list)


pathway.id <- "map00270"
object.id.list <- c("1.8.1.10", "1.8.4.3", "C00051")

pathway.id <- sub("^path:", "", pathway.id)
object.id.list <- paste(object.id.list, collapse="+")
pathway.id <- sprintf("%s+%s", pathway.id, object.id.list)

url <- sprintf("https://www.kegg.jp/pathway/%s", pathway.id)

res <- GET(url)
stop_for_status(res, "GET KEGG pathway URL")
content <- content(res, type="text", encoding = "UTF-8")
lines <- strsplit(content, "\n", fixed=TRUE)[[1]]
urlLine <- grep("<img src=\"/kegg", lines, value=TRUE)
path <- strsplit(urlLine, '"', fixed=TRUE)[[1]][2]
browseURL(sprintf("https://www.kegg.jp%s", path))

```

```{r}

# color.pathway.by.objects <- function(pathway.id, object.id.list, fg.color.list, bg.color.list)

pathway.id <- "map00270"
object.id.list <- "C00022"
fg.color.list <- "#00FF00"
bg.color.list <- "#0000FF"

pathway.id <- sub("^path:", "", pathway.id)
if (!(length(object.id.list)==length(fg.color.list) &&
      length(fg.color.list) == length(bg.color.list))) {
    stop(paste("object.id.list, fg.color.list, and bg.color.list must",
        "all be the same length."))
}

# format identifier/color list as expected by server
payload <- paste(
    c("#ids", object.id.list),
    c("cols", paste(bg.color.list, fg.color.list, sep=',')),
    sep="\t",
    collapse="\n"
)

# fetch KEGG page from server, via a 302 redirect handled by httr
# transparently
# res <- POST(
#     url = "https://www.kegg.jp/kegg-bin/show_pathway",
#     body = list(
#         map = pathway.id,
#         multi_query = payload,
#         mode = 'color'
#     ),
#     encode="multipart"
# )
res <- GET("https://www.genome.jp/kegg-bin/show_pathway?map00270/c00022%09%2300ff00,0000ff")
res <- content(res, "text")

# extract image URL from page
img_matches <- regexpr(
    "(?<=<img src=\")[^\"]+",
    res,
    perl=T
)
img_url <- regmatches(res, img_matches)
if (length(img_url) < 1) {
    stop(
        "'color.pathway.by.objects()' ",
        "failed to extract KEGG image path from response."
    )
}
if (length(img_url) > 1) {
    stop(
        "'color.pathway.by.objects()' ",
        "unexpectedly matched multiple KEGG image paths in response."
    )
}
browseURL(sprintf("https://www.kegg.jp%s", img_url))





```


```{r}
library(rvest)
library(chromote)

asdf <- read_html_live("https://www.genome.jp/kegg-bin/show_pathway?map00270/c00022%09%2300ff00,0000ff")$html_elements(css = "img")

asdf <- read_html_live("https://www.genome.jp/")$html_elements(css = "img")



url <- "https://www.forbes.com/top-colleges/"
sess <- read_html_live(url)
sess |> 
  html_elements(".TopColleges2023_tableRowGroup__65RHn") |> 
  html_elements(".TopColleges2023_tableRow__BYOSU")

```

