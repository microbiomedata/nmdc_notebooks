---
title: "Natural Organic Matter Data Notebook"
author: "Bea Meluch"
date: "2024-07-03"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, error = FALSE, warning = FALSE, message = FALSE)
library(tidyverse)
library(jsonlite)
library(heatmaply)
library(ggExtra)
```


How does the natural organic matter data in the NMDC database compare across sample types?

This notebook demonstrates how to use the existing NMDC-runtime API endpoints (as of August 2024) to explore the natural organic matter data present in the NMDC database. It traverses the database schema backwards, first pulling all available natural organic matter results, and then identifying the corresponding source samples. The processed data is then evaluated for quality and compared by sample type. Retrieving the CSV results files can be time consuming.


# Define functions to interact with API

## Define a general API call funtion to nmdc-runtime

This function provides a general-purpose way to make an API request to NMDC's runtime API. Note that this function will only return the first page of results. The function's input includes the name of the collection to access (e.g. biosample_set), the filter to be performed, the maximum page size, and a list of the fields to be retrieved. It returns the metadata as a dataframe.

```{r def-results-first}
get_first_page_results <- function(collection, filter, max_page_size, fields) {
  og_url <- paste0(
      'https://api.microbiomedata.org/nmdcschema/', 
      collection, '?&filter=', filter, '&max_page_size=', max_page_size, '&projection=', fields
      )
  
  response <- jsonlite::fromJSON(URLencode(og_url, repeated = TRUE))
  
  return(response)
}
```

## Define an nmdc-runtime API call function to include pagination

The get_next_results function uses the get_first_page_results function, defined above, to retrieve the rest of the results from a call with multiple pages. It takes the same inputs as the get_first_page_results function above: the name of the collection to be retrieved, the filter string, the maximum page size, and a list of the fields to be returned. This function returns the results as a single dataframe (can be nested). It uses the next_page_token key in each page of results to retrieve the following page.

```{r def-results-next}
get_next_results <- function(collection, filter_text, max_page_size, fields) {
  initial_data <- get_first_page_results(collection, filter_text, max_page_size, fields)
  results_df <- initial_data$resources
  
  if (!is.null(initial_data$next_page_token)) {
    next_page_token <- initial_data$next_page_token
    
    while (TRUE) {
      url <- paste0('https://api.microbiomedata.org/nmdcschema/', collection, '?&filter=', filter_text, '&max_page_size=', max_page_size, '&page_token=', next_page_token, '&projection=', fields)
      response <- jsonlite::fromJSON(URLencode(url, repeated = TRUE))

      results_df <- results_df %>% bind_rows(response$resources)
      next_page_token <- response$next_page_token
      
      if (is.null(next_page_token)) {
        break
      }
    }
  }
  
  return(results_df)
}
```



## Define an API request function that uses a list of ids to filter on

This function constructs a different type of API request that takes a list of ids or similar (e.g. `biosample` ids as retrieved above). The `id_field` input is a string of the name of the id field name (e.g. `id` or `has_output`), the name of the new collection to be queried, the name of the field to match the previous ids on in the new collection, and a list of the fields to be returned.

```{r def-results-id}
get_results_by_id <- function(collection, match_id_field, id_list, fields, max_id = 50) {
    # collection: the name of the collection to query
    # match_id_field: the field in the new collection to match to the id_list
    # id_list: a list of ids to filter on
    # fields: a list of fields to return
    # max_id: the maximum number of ids to include in a single query
    
    # If id_list is longer than max_id, split it into chunks of max_id
    if (length(id_list) > max_id) {
        id_list <- split(id_list, ceiling(seq_along(id_list)/max_id))
    } else {
        id_list <- list(id_list)
    }
    
    output <- list()
    for (i in 1:length(id_list)) {
        # Cast as a character vector and add double quotes around each ID
        mongo_id_string <- as.character(id_list[[i]]) %>%
            paste0('"', ., '"') %>%
            paste(collapse = ', ')
        
        # Create the filter string
        filter = paste0('{"', match_id_field, '": {"$in": [', mongo_id_string, ']}}')
        
        # Get the data
        output[[i]] = get_next_results(
            collection = collection,
            filter = filter,
            max_page_size = max_id*3, #assumes that there are no more than 3 records per query
            fields = fields
        )
    }
    output_df <- bind_rows(output)
}
```

# Query 

## get all NOM data

```{r}
# Get data objects using get_next_results function
nom_dobj_df <- get_next_results(
    collection = "data_object_set", 
    filter_text = '{"data_object_type": {"$regex": "FT ICR-MS Analysis Results"}}', 
    max_page_size = 100, 
    fields = "id,name,url,was_generated_by,md5_checksum"
    )
```


## get all nom analysis results by id 

```{r}
nom_analysis_df <- get_results_by_id(
    collection = "nom_analysis_activity_set",
    match_id_field = "has_output",
    id_list = nom_dobj_df$id,
    fields = "id,has_input,has_output",
    max_id = 20
) %>%
  mutate(has_input = unlist(has_input),
         has_output = unlist(has_output))

```

## get all dataobjects of raw NOM data by id
```{r}

nom_raw_df <- get_results_by_id(
    collection = "data_object_set",
    match_id_field = "id",
    id_list = nom_analysis_df$has_input,
    fields = "id,was_generated_by,name,md5_checksum",
    max_id = 20
)

# uh oh, there are dobj with no was_generated_by, summarize
# nom_raw_df %>%
#   filter(is.na(was_generated_by)) %>%
#   mutate(name_prefix = str_match(name, "^(output: [A-Za-z]+)_")[,2]) %>%
#   count(name_prefix)

```

## get all omicsprocessing records by id
```{r}

nom_omprc_df <- get_results_by_id(
    collection = "omics_processing_set",
    match_id_field = "has_output",
    id_list = nom_raw_df$id,
    fields = "id,has_input,has_output",
    max_id = 20
) %>%
  mutate(has_input = unlist(has_input),
         has_output = unlist(has_output))

```

## get all biosample records by id
```{r}

nom_biosample_df <- get_results_by_id(
    collection = "biosample_set",
    match_id_field = "id",
    id_list = nom_omprc_df$has_input,
    fields = "id,name,part_of,analysis_type,geo_loc_name,env_medium,lat_lon",
    #fields = "",
    max_id = 20
)

```

## combine records into one data frame

```{r}

nom_objects_joined <- nom_biosample_df %>%
  rename_with(~ paste0("bsm.", .x)) %>%
  full_join(rename_with(nom_omprc_df, ~ paste0("omprc.", .x)), 
            by = join_by(bsm.id == omprc.has_input),
            keep = TRUE) %>%
  full_join(rename_with(nom_raw_df, ~ paste0("raw.", .x)), 
            by = join_by(omprc.has_output == raw.id),
            keep = TRUE) %>%
  full_join(rename_with(nom_analysis_df, ~ paste0("analysis.", .x)), 
            by = join_by(raw.id == analysis.has_input),
            keep = TRUE) %>%
  full_join(rename_with(nom_dobj_df, ~ paste0("dobj.", .x)), 
            by = join_by(analysis.has_output== dobj.id),
            keep = TRUE) %>%
  
  # clean up: remove duplicate rows produced by joins
  distinct() %>%
  
  # flatten list-columns
  unnest(where(is.data.frame), names_sep = ".", keep_empty = TRUE) %>%
  unnest(where(is.data.frame), names_sep = ".", keep_empty = TRUE) %>%
  mutate(across(where(is.list), as.character)) %>%
  
  # remove duplicate processed data objects
  filter(!duplicated(dobj.md5_checksum))


```



# Label sample types
```{r sample-types}

nom_objects_joined_labeled <- nom_objects_joined %>%


  mutate(bsm.sample_type_manual = case_when(
    bsm.env_medium.term.id %in% c("UBERON:0035118", "ENVO:00002003") ~ "host",
    str_detect(bsm.name, "hizosphere") ~ "plant",
    str_detect(bsm.env_medium.term.id, "PO:") ~ "plant",
    bsm.env_medium.term.id %in% c("ENVO:00001998", "ENVO:00005774", "ENVO:00002258", "ENVO:00005778", "ENVO:00005802", 
                                  "ENVO:02000059", "ENVO:00005741", "ENVO:01001841", "ENVO:00003082", "ENVO:00005800", "ENVO:01000018") ~ "soil",
    bsm.env_medium.term.id %in% c("ENVO:00002007", "ENVO:01000017", "ENVO:03605004", "ENVO:03605005") ~ "sediment",
    bsm.env_medium.term.id %in% c("ENVO:00002042", "ENVO:00002011", "ENVO:00002194", "ENVO:01001869", "ENVO:04000007") ~ "water",
    bsm.env_medium.term.id %in% c("ENVO:01000349", "ENVO:01001001", "ENVO:03605005") ~ "plant",
    str_detect(bsm.env_medium.term.name, "soil") ~ "soil",
    str_detect(bsm.env_medium.has_raw_value, "soil") ~ "soil",
    str_detect(bsm.env_medium.term.name, "water") ~ "water",
    bsm.part_of == "nmdc:sty-11-pzmd0x14" ~ "sediment"
  ))

```

# Pull processed data

```{r}
# Pull processed data files using URLs from processed data dobj
# processed_data_csvs <- data.frame(data_object_url = nom_objects_joined_labeled$dobj.url) %>%
#   filter(!is.na(data_object_url)) %>%
#   mutate(csv_nested = lapply(data_object_url, read.csv))
# 
# saveRDS(processed_data_csvs, "processed_data_csvs.RDS")

processed_data_csvs <- readRDS("processed_data_csvs.RDS")

```

## Quality metrics for processed data
```{r qc}

# Extract and calculate some statistics for the processed data
processed_data_qc <- processed_data_csvs %>%
  
  mutate(median_confidence  = vapply(csv_nested, function(x) median(x$Confidence.Score, na.rm = TRUE), 
                                     FUN.VALUE = 1.0, USE.NAMES = FALSE),
         
         unassigned_count   = vapply(csv_nested, function(x) sum((x$Molecular.Formula == "")), 
                                     FUN.VALUE = 1, USE.NAMES = FALSE),
         
         assigned_count     = vapply(csv_nested, function(x) sum((x$Molecular.Formula != "")), 
                                     FUN.VALUE = 1, USE.NAMES = FALSE),
         
         assigned_perc      = assigned_count / (unassigned_count + assigned_count),
         
         #molecular_formulae = lapply(csv_nested, function(x) unique(x$Molecular.Formula)),
         
         confidence_scores  = lapply(csv_nested, function(x) x$Confidence.Score)) 

# Plots to visually assess quality cutoffs
ggplot(processed_data_qc) +
  geom_histogram(aes(x = median_confidence), bins = 20) +
  ggtitle("Median Confidence Scores for Processed Data Files")

ggplot(processed_data_qc) +
  geom_histogram(aes(x = assigned_perc)) +
  ggtitle("Percent Assigned Peaks for Processed Data Files")

data.frame(All_Confidence_Scores = unlist(processed_data_qc$confidence_scores)) %>%
  ggplot() +
    geom_histogram(aes(x = All_Confidence_Scores), bins = 30) +
    ggtitle("Confidence Scores for All Peak/Formula Assignments")

```

```{r quality-filtering}

# filter out samples with low percent assigned
processed_data_qc <- processed_data_qc %>%
  filter(assigned_perc > 0.3) %>%
  
  # within data, filter out rows with low confidence score
  mutate(csv_nested = lapply(csv_nested, function(x) filter(x, Confidence.Score > 0.6)))

```



```{r formula-heatmap}


samples_for_heatmap <- processed_data_qc %>%
  
  # extract molecular formulae
  mutate(molecular_formulae = lapply(csv_nested, function(x) unique(x$Molecular.Formula))) %>%
  
  # remove nested csv column because it's so slow
  select(-csv_nested) %>%
  
  # add biosample info
  left_join(select(nom_objects_joined_labeled, dobj.url, 
                   bsm.id, bsm.sample_type_manual, bsm.part_of, 
                   bsm.lat_lon.latitude, bsm.lat_lon.longitude), 
            by = join_by(data_object_url == dobj.url)) %>%
  
  # sample 33 of each sample type
  group_by(bsm.sample_type_manual) %>%
  slice_sample(n = 33) %>%
  ungroup()

# Filter out molecular formulae that appear in less than 5 samples
# so the heatmap isn't impossible
filtered_formulae <- samples_for_heatmap$molecular_formulae %>%
  unlist() %>%
  table() %>%
  as.data.frame() %>%
  setNames(c("Formula", "Freq")) %>%
  filter(Formula != "") %>%
  filter(Freq > 5) %>%
  mutate(Formula = as.character(Formula)) %>%
  pull(Formula)
  

# initialize presence absence matrix
# rows are samples
# columns are molecular formulae
holder <- matrix(, nrow = nrow(samples_for_heatmap), ncol = length(filtered_formulae))

for (i in 1:nrow(samples_for_heatmap)) {
  holder[i,] <- ifelse(filtered_formulae %in% samples_for_heatmap$molecular_formulae[[i]], 
                       1, 0)
}

rownames(holder) <- samples_for_heatmap$bsm.id
colnames(holder) <- filtered_formulae

# set up color vectors for side grouping columns

sample_type_color_vec <- case_when(
  samples_for_heatmap$bsm.sample_type_manual == "soil" ~ "saddlebrown",
  samples_for_heatmap$bsm.sample_type_manual == "sediment" ~ "slategray",
  samples_for_heatmap$bsm.sample_type_manual == "water" ~ "blue")

study_color_vec <- case_when(
  samples_for_heatmap$bsm.part_of == "nmdc:sty-11-aygzgv51" ~ "red",
  samples_for_heatmap$bsm.part_of == "nmdc:sty-11-5tgfr349" ~ "orange",
  samples_for_heatmap$bsm.part_of == "nmdc:sty-11-28tm5d36" ~ "yellow",
  samples_for_heatmap$bsm.part_of == "nmdc:sty-11-db67n062" ~ "green",
  samples_for_heatmap$bsm.part_of == "nmdc:sty-11-dcqce727" ~ "blue",
  samples_for_heatmap$bsm.part_of == "nmdc:sty-11-8xdqsn54" ~ "purple",
  samples_for_heatmap$bsm.part_of == "nmdc:sty-11-33fbta56" ~ "pink"
  )


create_colors_from_numeric <- function(num_vec, pal) {
  # pal = grDevices Palette (others may work idk)
  pal[findInterval(num_vec, seq(min(num_vec), max(num_vec), length.out = length(pal) + 1), all.inside=TRUE)]
}

latitude_color_vec <- map2color(samples_for_heatmap$bsm.lat_lon.latitude, hcl.colors(200, palette = "Oranges"))


heatmap(holder, Colv = NA, RowSideColors = latitude_color_vec, labRow = FALSE, labCol = FALSE, scale = "none")

heatmaply(holder, Colv = NA, RowSideColors = cbind(sample_type_color_vec, study_color_vec, latitude_color_vec), showticklabels = FALSE, hide_colorbar = TRUE)


  
  




```


```{r van-krevelen}

# extract oc and hc ratios for the same samples as used in the heatmap

samples_for_heatmap %>%
  select(data_object_url, bsm.id, bsm.sample_type_manual, bsm.part_of) %>%
  left_join(processed_data_csvs) %>%
  mutate(HC = lapply(csv_nested, function(x) x$H.C),
         OC = lapply(csv_nested, function(x) x$O.C)) %>%
  select(-csv_nested) %>%
  unnest() %>%

  ggplot(aes(x = OC, y = HC, color = bsm.sample_type_manual)) +
    geom_point(alpha = 0.1, size = 0.5) +
    facet_wrap(~bsm.sample_type_manual) +
    theme(legend.position = "none") +
    coord_fixed() +
    scale_color_manual("legend", values = c("soil" = "saddlebrown",
                                            "sediment" = "slategray",
                                            "water" = "blue"))


```


```{r van-krevelen-common-formulae}

samples_for_heatmap %>%
  select(data_object_url, bsm.sample_type_manual) %>%
  left_join(processed_data_csvs) %>%
  mutate(csv_nested = lapply(csv_nested, select, Molecular.Formula, H.C, O.C)) %>%
  unnest(csv_nested) %>%
  # remove blank rows left over from csv (unassigned rows)
  filter(!is.na(H.C)) %>%
  # remove biosample and data object info - we just want formulae and sample types really
  select(-data_object_url) %>%
  mutate(exists = TRUE) %>%
  filter(!duplicated(.)) %>%
  pivot_wider(names_from = bsm.sample_type_manual, values_from = exists) %>%
  mutate(across(where(is.logical), ~ !is.na(.x))) %>%
  # label all shared formulae
  mutate(in_soil_only = soil & !sediment & !water,
         in_water_only = !soil & !sediment & water,
         in_sediment_only = !soil & sediment & !water,
         # in_soil_and_sediment = soil & sediment & !water,
         # in_soil_and_water = soil & water & !sediment,
         # in_water_and_sediment = water & sediment & !soil,
         in_all_sample_types = sediment & soil & water) %>%
  select(-soil, sediment, water) %>%
  pivot_longer(cols = starts_with("in_"), 
               names_to = "sample_type", values_to  = "presence") %>%
  filter(presence) %>%
  
  # prettier labels
  mutate(sample_type = case_when(
    sample_type == "in_soil_only" ~ "Unique to soil samples",
    sample_type == "in_water_only" ~ "Unique to water samples",
    sample_type == "in_sediment_only" ~ "Unique to sediment samples",
    sample_type == "in_all_sample_types" ~ "Present in all sample types"
  )) %>%
  
  ggplot(aes(x = O.C, y = H.C, color = sample_type)) +
    geom_point(alpha = 0.5, size = 1, shape = 1) +
    theme(legend.position = "bottom",
          plot.title = element_text(margin = margin(t = 1, unit = "cm"), size = 12)) +
    labs(title = "Van Krevelen: unique and shared molecular formulae by sample type",
         x = "O/C Ratio", y = "H/C Ratio", color = "Sample Type") +
    #coord_fixed() +
    guides(color = guide_legend(override.aes = list(alpha = 1, size = 3))) +
    scale_color_manual("legend", 
                       values = c("Unique to soil samples" = "saddlebrown", 
                                 "Unique to water samples" = "blue", 
                                 "Unique to sediment samples" = "red", 
                                 # "in_soil_and_sediment" = "sienna", 
                                 # "in_soil_and_water" = "purple", 
                                 # "in_water_and_sediment" = "green", 
                                 "Present in all sample types" = "black")) -> shared_van_krevelen
  
  ggMarginal(shared_van_krevelen, groupColor = TRUE, groupFill = TRUE) -> shared_van_krevelen

```